<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clase 08</title>
</head>
<body>
    <h2>Selectores avanzados y Animaciones</h2>
    <h3>Selectores avanzados</h3>
    <p>Los selectores avanzados son aquellos que nos permiten seleccionar elementos de acuerdo a su posición en el documento, o bien, de acuerdo a su posición en relación a otros elementos.</p>
    <img src="/CSS/Clase 08 - CSS 4/img/selectores-avanzados.png" alt="">
    <img src="/CSS/Clase 08 - CSS 4/img/selectores-avanzados2.png" alt="">
    <h3>Pseudoclases</h3>
    <p>Una pseudoclase es un selector que marca los elementos que están en un
        estado específico o tienen un comportamiento determinado. Todas las
        pseudoclases se denominan mediante una palabra precedida por dos puntos y
        se comportan del mismo modo. Afectan a un fragmento del documento que
        está en un estado determinado y se comportan como si se hubiera añadido
        una clase a su HTML.</p>
    <h3>:first-child</h3>
    <p>Esta pseudoclase modifica el estilo del primer elemento de un grupo de
        elementos hermanos dentro de un contenedor, es decir “el primer hijo de su
        padre”.</p>
    <img src="/CSS/Clase 08 - CSS 4/img/first-child.png" alt="">
    <h3>:last-child</h3>
    <p>Se utiliza para representar al último elemento entre un grupo de elementos
        hermanos dentro de un contenedor, es decir “el último hijo de su padre”.</p>
    <img src="/CSS/Clase 08 - CSS 4/img/last-child.png" alt="">
    <h3>:nth-child()</h3>
    <p>El selector coincide con cada elemento que es el n-ésimo hijo,
        independientemente del tipo, de su padre. n puede ser un número, una palabra
        clave o una fórmula.</p>
    <img src="/CSS/Clase 08 - CSS 4/img/nth-child.png" alt="">
    <h3>Pseudoclases para hipervínculos</h3>
    <p>Se aplican a las etiquetas <a>, que pueden tener cuatro estados:</p>
    <ul>
        <li><b>:link</b> se refiere a un enlace que todavía no ha sido visitado.</li>
        <li><b>:hover</b> se refiere a un elemento sobre el que se coloca el puntero del mouse.</li>
        <li><b>:visited</b> se refiere a un enlace que ya ha sido visitado.</li>
        <li><b>:active</b> se refiere a cualquier elemento que ha sido activado por el usuario.</li>
    </ul>
    <img src="/CSS/Clase 08 - CSS 4/img/pseudoclases-para-hipervínculos.png" alt="">
    <h3>Pseudoelementos</h3>
    <p>Los pseudoelementos se añaden a los selectores, pero no describen un estado
        especial sino que permiten añadir estilos a una parte concreta del documento.</p>
    <p>Se utilizan para darle estilos a partes específicas de un elemento. Están
        precedida por cuatro puntos (: :):
        </p>
    <ul>
        <li><b>::first-letter</b> se utiliza para darle estilo a la primera letra de un texto:</li><img src="/CSS/Clase 08 - CSS 4/img/Pseudoelementos.png" alt="">
        <li><b>::selection</b> agrega estilos a una parte del documento que ha sido resaltada por el
            usuario:</li>
            <img src="/CSS/Clase 08 - CSS 4/img/selection.png" alt="">
        <li><b>::before</b> y <b>::after</b> agregan contenido antes y después, respectivamente, del
            contenido:</li>
            <img src="/CSS/Clase 08 - CSS 4/img/before-and-after.png" alt="">
    </ul>
    <h2>Transformaciones, animaciones y transiciones</h2>
    <p>Permiten mover, rotar, escalar y sesgar elementos, es decir, efectos visuales en
        2D y 3D. Las propiedades principales para realizar transformaciones son las
        siguientes:</p>
    <img src="/CSS/Clase 08 - CSS 4/img/Transformaciones.png" alt="">
    <p>Con la propiedad transform podemos indicar una o varias transformaciones para
        realizar sobre un elemento, ya sean 2D (sobre dos ejes) o 3D (sobre tres ejes).</p>
    <h4>2D - Traslaciones (translate)</h4>
    <p>Las funciones de traslación son aquellas que realizan una transformación en la
        que mueven un elemento de un lugar a otro. Si especificamos un valor positivo
        en el eje X (horizontal), lo moveremos hacia la derecha, y si especificamos un
        valor negativo, lo moveremos hacia la izquierda. Lo mismo con el eje Y (vertical).
        Por ejemplo, transform: translate(20px, -30px) traslada el elemento 20 píxeles a la
        derecha y 30 píxeles hacia arriba, que es equivalente a utilizar transform:
        translateX(20px) translateY(-30px).</p>
    <img src="/CSS/Clase 08 - CSS 4/img/Traslaciones.png" alt="">
    <h4>2D - Escalado (scale)</h4>
    <p>Las funciones de escalado realizan una transformación en la que aumentan o
        reducen el tamaño de un elemento, basándose en el parámetro indicado, que
        no es más que un factor de escala:
        En este ejemplo, transform: scale(2, 2) realiza una transformación de escalado del
        elemento, ampliándolo al doble de su tamaño original. Si utilizamos scale() con
        dos parámetros iguales, estamos manteniendo la proporción del elemento, pero
        si utilizamos diferentes valores, acabaría deformandose.</p>
        <img src="/CSS/Clase 08 - CSS 4/img/scale.png" alt="">
    <h4>2D - Rotaciones (rotate)</h4>
    <p>Las funciones de rotación simplemente giran el elemento el número de grados
        indicado:
        Con transform: rotate(5deg) realizamos una rotación de 5 grados del elemento
        sobre sí mismo. Utilizando rotateX() y rotateY() podemos hacer lo mismo
        respecto al eje X o el eje Y respectivamente.</p>
    <img src="/CSS/Clase 08 - CSS 4/img/rotate.png" alt="">
    <h4>Funciones 3D</h4>
    <p>A las funciones anteriores, también podemos añadir las funciones equivalentes
        de CSS para hacer uso del eje Z y con esto acceder a las dimensiones espaciales
        o “3D”. Las propiedades de transformación 3D son las siguientes:</p>
        <img src="/CSS/Clase 08 - CSS 4/img/funciones-3d.png" alt="">
    <h3>Transformaciones múltiples</h3>
    <p>Si indicamos dos propiedades transform en el mismo elemento, con diferentes
        funciones, la segunda propiedad sobreescribirá a la anterior, como ocurre con
        cualquier propiedad de CSS:</p>
    <img src="/CSS/Clase 08 - CSS 4/img/multiples-transform.png" alt="">
    <p>Para evitar esto se suelen emplear múltiples transformaciones, separándolas
        mediante un espacio. En el siguiente ejemplo, aplicamos una función de
        rotación, una función de escalado y una función de traslación de forma
        simultánea:</p>
    <img src="/CSS/Clase 08 - CSS 4/img/multiples-transformaciones.png" alt="">
        <h3>Transiciones</h3>
        <p>Las transiciones CSS le permiten cambiar los valores de una propiedad, durante un
        período determinado. Se basan en un principio muy básico: conseguir un cambio de
        estilo con un efecto suavizado entre un estado inicial y un estado final.
        Para crear un efecto de transición, debemos especificar dos cosas: <br>
        ● La propiedad CSS a la que desea agregar un efecto (¿qué propiedad modifico?) <br>
        ● La duración del efecto (¿durante cuánto tiempo?) <br>
        Las propiedades relacionadas que existen son las siguientes:</p>
    <img src="/CSS/Clase 08 - CSS 4/img/transiciones.png" alt="">
    <ul>
        <li><b>transition-property:</b> Indica la propiedad que será afectada por la transición.
                Puede ser una propiedad concreta (width o color, por ejemplo) o
                simplemente all para que se aplique a todos los elementos. Por otro lado,
                none hace que no se aplique ninguna transición.</li>
        <li><b>transition-duration:</b> Establece la duración de la transición. Se recomienda
                comenzar con valores cortos, para que las transiciones sean rápidas y
                elegantes. Una duración demasiado grande producirá una transición con
                detenciones intermitentes, y pueden resultar molestas a muchos usuarios.</li>
        <li><b>transition-timing-function:</b> indica el ritmo de la transición que queremos
                conseguir. Se recomienda comenzar con linear (ritmo constante) y luego
                utilizar otros valores para variar el ritmo sea al inicio y/o al final de la
                transición.</li>
            <img src="/CSS/Clase 08 - CSS 4/img/transition-timing-function.png" alt="">
            <p>Un valor linear siempre es constante, mientras que ease comienza suavemente,
                    aumenta la velocidad y finaliza suavemente. Ease-in y ease-out son variaciones que
                    van más lento al principio o al final, y ease-in-out una mezcla de ambas.
                    La función Cubic-Bezier() nos permite configurar con más detalle la transición.</p>
        </ul>
    <h3>La función de tiempo Cubic-Bezier()</h3>
        <p>Es una función personalizada. Podemos asignar valores que definen la velocidad que
        queramos que tenga la transición. En la última columna de la tabla anterior podemos
        ver los valores equivalentes a cada una de las palabras clave mencionadas. En
        principio, el formato de la función es cubic-bezier(A, B, C, D), donde:</p>
    <img src="/CSS/Clase 08 - CSS 4/img/Cubic-Bezier().png" alt="">
    <p>transition-delay nos ofrece la posibilidad de retrasar el inicio de la transición los
            segundos especificados.</p>
    <h4>Atajo: Transiciones</h4>
    <p>Como siempre, podemos resumir todas estas operaciones en una propiedad de atajo
        denominada transition. Los valores del ejemplo superior, se podrían escribir como se
        puede ver a continuación (si no necesitas algún valor, se puede omitir):</p>
    <img src="/CSS/Clase 08 - CSS 4/img/" alt="">
    <h2>Animaciones</h2>
    <p>Una animación permite que un elemento cambie gradualmente de un estilo a otro.
        Podemos cambiar tantas propiedades CSS como deseemos, tantas veces como sea
        necesario.
        Las animaciones amplían el concepto de transiciones convirtiéndolo en algo mucho más
        flexible y potente, partiendo del mismo concepto de realizar cambios en ciertos estados
        inicial y final pero incorporando más estados, pudiendo realizar cambios desde un estado
        inicial, a un estado posterior, a otro estado posterior, y así sucesivamente. Además, esto
        será posible de forma automática, sin que el usuario tenga que realizar una acción
        concreta.
        Para utilizar la animación CSS, primero debemos especificar algunos fotogramas clave
        (@keyframes) para la animación, que contendrán los estilos que tendrá el elemento en
        determinados momentos. Además tendremos que utilizar las propiedades de las
        animaciones, que definen el comportamiento de la misma.</p>
    <h3>Propiedades de animación CSS</h3>
    <img src="/CSS/Clase 08 - CSS 4/img/propiedades-animacion.png" alt="">
    <p><b>animation-name</b> permite especificar el nombre del fotograma a utilizar. <b>animation-duration</b>,<b>animation-timing-function</b> y <b>animation-delay</b> funcionan exactamente igual que en transiciones.</p>
    <p>La propiedad animation-iteration-count permite indicar el número de veces que se
            repite la animación, pudiendo establecer un número concreto de repeticiones o
            indicando infinite para que se repita continuamente. Por otra parte, especificando un
            valor en animation-direction conseguiremos indicar el orden en el que se reproducen
            los fotogramas, pudiendo escoger un valor de los siguientes:</p>
            <img src="/CSS/Clase 08 - CSS 4/img/propiedades-animation-2.png" alt="">
    <p>Por defecto, cuando se termina una animación que se ha indicado que se reproduzca
            sólo una vez, la animación vuelve a su estado inicial (primer fotograma).
            Mediante la propiedad <b>animation-fill-mode</b> podemos indicar que debe mostrar la
            animación cuando ha finalizado y ya no se está reproduciendo; si mostrar el estado
            inicial (backwards), el estado final (forwards) o una combinación de ambas (both).
            La propiedad <b>animation-play-state</b> nos permite establecer la animación a estado de
            reproducción (running) o pausarla (paused).</p>
    <h3>Atajo: Animaciones</h3>
    <p>Nuevamente, CSS ofrece la posibilidad de resumir todas estas propiedades en una
            sola, para hacer nuestras hojas de estilos más específicas. El orden de la propiedad de
            atajo sería el siguiente:</p>
    <img src="/CSS/Clase 08 - CSS 4/img/atajos-animation.png" alt="">
    <p>Debemos ser cuidadosos al indicar el tiempo en las propiedades de duración. Al ser
            una unidad diferente a las que solemos manejar (px, em, etc...) hay que especificar
            siempre la s, por segundos, aunque sea un valor igual a 0.</p>
    <h2>Fotogramas (keyframes)</h2>
    <p>Para definir los fotogramas de una animación utilizaremos la regla @keyframes.
        Primero elegimos un nombre para la animación (ya que podemos tener varias en una
        misma página), mientras que podremos utilizar varios selectores para definir el
        transcurso de los fotogramas en la animación.</p>
    <img src="/CSS/Clase 08 - CSS 4/img/keyframes.png" alt="">
    <p>En este ejemplo partimos de un primer fotograma con un elemento con color de
        fondo rojo. Si observamos el último fotograma, indicamos finalice con color de fondo
        verde. La regla @keyframes creará la animación intermedia para conseguir que el
        elemento cambie de color.
        Los selectores from y to son realmente sinónimos de 0% y 100%. Al modificarlos
        podremos ir añadiendo nuevos fotogramas intermedios:</p>
    <img src="/CSS/Clase 08 - CSS 4/img/key-frames-2.png" alt="">
    <p>Es posible encadenar múltiples animaciones, separando con comas las
    <h3>Encadenar animaciones</h3>
            animaciones individuales y estableciendo un tiempo de retardo a cada
            animación posterior:</p>
    <img src="/CSS/Clase 08 - CSS 4/img/encadenar-animaciones.png" alt="">
    <p>Hemos aplicado varias animaciones a la vez, estableciendo un retardo
            equivalente a la suma de la duración de las animaciones anteriores,
            encadenando una animación con otra.</p>
    <h3>Librería de animaciones Animate.css</h3>
    <a href="https://animate.style">Animar.css</a>
    <p>Podemos utilizar Animate.css para dar dinamismo a nuestro contenido. Ingresar

        ● En pocos pasos se pueden agregar animaciones CSS a cualquier elemento
        con esta sencilla librería.
        ● En la creación de cualquier contenido web resulta interesante incorporar
        animaciones que nos ayuden a mejorar la experiencia del usuario durante la
        interacción con el contenido.
        ● Permite disponer de una gran variedad de animaciones CSS sin necesidad de
        crearlas nosotros mismos.
        ● Esta librería permite conseguir que el contenido sea más atractivo y
        dinámico.</p>
    <h2>Introducción Responsive Web Design.</h2>
    <p>El diseño web responsivo se trata de usar HTML y CSS para cambiar el
        tamaño, ocultar, reducir o ampliar automáticamente un sitio web, para que
        se vea bien en todos los dispositivos (computadoras de escritorio, tabletas y
        teléfonos)
        Una web responsive es aquella que es capaz de adaptarse a cualquier
        dispositivo, ya sean computadoras, portátiles, tablets o smartphones. Y en
        cada uno de estos dispositivos el sitio web debe visualizarse correctamente.
        El diseño responsivo se encarga precisamente de esto, de responder al
        tamaño de los dispositivos desde los que se visualizan los contenidos web,
        adaptando sus dimensiones y mostrando los componentes de manera
        optimizada y ordenada sin importar el tipo de soporte que sea.</p>
    <h3>Diseño responsivo vs Diseño adaptativo</h3>
    <p>Un diseño responsivo responde a las
        dimensiones del dispositivo, mientras que un
        diseño adaptativo se adapta, pero no
        necesariamente responde en todo momento,
        tiene cierto delay, estamos hablando casi de
        lo mismo.
        El diseño web responsivo adapta la estructura
        y los diferentes elementos de cada página
        web a las dimensiones y características de
        cada pantalla. Por otro lado, el diseño web
        adaptativo es menos flexible, y se basa en el
        
        uso de tamaños y características pre-
        establecidas. Las diferencias entre ambos
        
        métodos se encuentran en el proceso
        creativo y de diseño, en el resultado final y la
        experiencia del usuario.</p>
        <img src="/CSS/Clase 08 - CSS 4/img/responsive.png" alt="">
    <h3>Flujo (The Flow) vs Estático (Static)</h3>
    <p>Cuando una pantalla se vuelve más pequeña, el contenido comienza a crecer
        verticalmente ocupando más espacio, y el contenido que se encuentra debajo va
        a ser desplazado hacia abajo, eso se llama flujo.
        Si es estático ese flujo de elementos no se desplaza, no se adapta al ancho del
        viewport y se pierde contenido o cierto contenido tapa a otro.</p>
        <img src="/CSS/Clase 08 - CSS 4/img/flujos.png" alt="">
    <h3>Unidades Relativas vs Unidades Absolutas</h3>
    <p>La densidad de píxeles de cada dispositivo puede variar, por eso necesitamos
        unidades que sean flexibles y funcionen sin importar el dispositivo. Ahí es donde
        las unidades relativas como los porcentajes son útiles. Entonces, hacer algo con
        un 50% de ancho significa que siempre ocupará la mitad de la pantalla (viewport,
        el tamaño de la ventana del navegador abierta), independientemente del
        dispositivo.</p>
    <img src="/CSS/Clase 08 - CSS 4/img/unidades-relativas-absolutas.png" alt="">
    <h3>Valores Mínimos y Máximos</h3>
    <p>En un celular nos puede interesar que determinado contenido ocupe todo el
        ancho de la pantalla, pero al pasar a un TV 4K podríamos cambiar de idea. Por
        ejemplo podríamos tener un width:100%, pero con un max width: 1000px.
        En un celular, las imágenes pueden tener un ancho diferente a las que vemos en
        otras pantallas. El alto no importa tanto en mobile, porque podemos scrollear.</p>
    <img src="/CSS/Clase 08 - CSS 4/img/valores-min-max.png" alt="">
    <h3>Puntos de Control (Breakpoints)</h3>
    <p>Estos puntos de control permiten al diseño cambiar en determinados puntos,
        por ej, en un monitor podemos tener 3 columnas, pero sólo 1 en un celular (que
        es más angosto). Estos puntos de control o de quiebre se crean con los media
        queries, que nos permiten determinar que si el mínimo del ancho de la pantalla
        tiene un valor en lugar de otro, en vez de distribuir el contenido en tres columnas
        colocarlo en una sola, con varias filas.</p>
    <img src="/CSS/Clase 08 - CSS 4/img/breakpoints.png" alt="">
    <img src="/CSS/Clase 08 - CSS 4/img/breakspoints2.png" alt="">
    <img src="/CSS/Clase 08 - CSS 4/img/breakspoints3.png" alt="">
    <img src="/CSS/Clase 08 - CSS 4/img/breakspoints4.png" alt="">
    <h3>Objetos anidados (Nested Objects)</h3>
    <p>Tener muchos objetos que dependan de otros puede ser difícil de controlar, sin
        embargo, agruparlos en contenedores nos puede simplificar las cosas.
        ¿Por qué usamos contenedores? Porque a la hora de pensar contenido
        responsive nos va a facilitar posicionar un grupo de elementos en otro lugar.</p>
    <img src="/CSS/Clase 08 - CSS 4/img/Nested-Objects.png" alt="">
    <h3>Mobile first vs Desktop first</h3>
    <p>
        ● Mobile first: Primero nos enfocamos en dispositivos móviles y luego pensamos en otros. <br>
        ● Desktop first: Primero nos enfocamos en dispositivos de escritorio, y luego pensamos en
        otros.</p>
    <p>Estadísticamente, los dispositivos móviles son mayoritariamente los que
        acceden a los sitios Web. Los dispositivos de escritorio tienden a utilizarse cada
        vez menos.</p>
    <img src="/CSS/Clase 08 - CSS 4/img/mobile-desktop.png" alt="">
    <h3>System Font vs WebFonts</h3>
    <p>
        ● Fuentes de la Web: son descargadas por lo que, cuantas más haya, más lento cargará el
        sitio. <br>
        ● Fuentes del Sistema: más rápidas, pero si NO están en el cliente navegador del usuario
        se usa una por defecto. <br>
        Cuando estamos trabajando con dispositivos móviles tenemos que tener en
        cuenta que todo se carga.</p>
    <h3>Bitmaps vs Vectors</h3>
    <p><b>Bitmaps</b>: JPG, PNG, GIF. Recomendadas para muchos detalles y efectos. <br>
        <b>Vectors:</b> SVG (gráficos basados en vectores escalables), si voy a mostrar un ícono
        uso Icon Fonts, que son más livianos, pero algunos exploradores viejos no los
        soportan.</p>
    <h3>Texto responsivo</h3>
    <p>Recordemos que el tamaño del texto se puede configurar con una unidad "vw",
        que es el "ancho de la ventana gráfica". De esa forma, el tamaño del texto seguirá
        el tamaño de la ventana del navegador.</p>
    <img src="/CSS/Clase 08 - CSS 4/img/text-responsiv.png" alt="">
    <p>Viewport es el tamaño de la ventana del navegador.
        1vw = 1% del ancho de la ventana gráfica.</p>
    <h3>Imágenes responsivas</h3>
    <p>Las imágenes responsivas son imágenes que se escalan bien para adaptarse a
        cualquier tamaño de navegador.
        Si la propiedad CSS width se establece en 100%, la imagen responderá y se
        ampliará y reducirá.
        Una imagen grande puede ser perfecta en una pantalla de computadora
        grande, pero inútil en un dispositivo pequeño. ¿Por qué cargar una imagen
        grande cuando tiene que reducirla de todos modos? Para reducir la carga, o por
        cualquier otro motivo, puede utilizar media queries para mostrar diferentes
        imágenes en diferentes dispositivos.</p>
    <h3>Display</h3>
    <p>
        Cada elemento tiene un valor de display por defecto. Recordemos que los
        navegadores le dan a los elementos valores por defecto block e inline:
        ● block: el elemento empieza en una nueva línea (div, h1-h6, header, etc) <br>
        ● inline: puede contener algo de texto dentro de un párrafo sin interrumpir el
        flujo del párrafo. <br>
        ● none: es utilizado para ocultar elementos sin eliminarlos, no deja un espacio
        donde el elemento se encontraba. <br>
        ● inline-block: Los elementos inline-block fluyen con el texto y demás
        elementos como si fueran elementos en línea y además respetan el ancho, el
        alto y los márgenes verticales. <br>
        Cada etiqueta HTML tiene un tipo de representación visual en un navegador, lo
        que habitualmente se suele denominar el tipo de caja. En principio, se parte de
        dos tipos básicos: inline y block.</p>
    <h3>Tipos de display</h3>
    <img src="/CSS/Clase 08 - CSS 4/img/Tipos-de-display.png" alt="">
    <h3>Ocultar elementos</h3>
    <p>En la lista anterior, falta un valor de la propiedad display. Mediante la
        mencionada propiedad, es posible aplicar un valor none y ocultar
        completamente elementos que no queramos que se muestren. Es muy útil para
        hacer desaparecer información cuando el usuario realiza alguna acción, por
        ejemplo.</p>
    <img src="/CSS/Clase 08 - CSS 4/img/ocultar-elementos.png" alt="">
    <p>No obstante, también existe una propiedad CSS llamada visibility que realiza la
        misma acción, con la ligera diferencia de que no sólo oculta el elemento, sino
        que además mantiene un vacío con el mismo tamaño de lo que antes estaba
        ahí. Dicha propiedad visibility puede tomar los siguientes valores:</p>
    <img src="/CSS/Clase 08 - CSS 4/img/ocultar-elementos2.png" alt="">
    <p>Utilizar visibility: hidden es muy interesante si queremos que un elemento y su
        contenido se vuelva invisible, pero siga ocupando su espacio y así evitar que los
        elementos adyacentes se desplacen, lo que suele ser un comportamiento no
        deseado en algunas ocasiones cuando se aplica display: none.
        Otra opción interesante es utilizar la propiedad opacity junto a transiciones o
        animaciones, desplazarse desde el valor 0 al 1 o viceversa. De esta forma
        conseguimos una animación de aparición o desvanecimiento.</p>
    </body>     
</html>